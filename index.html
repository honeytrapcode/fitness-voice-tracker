<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tracker</title>
   <style>
       
        body {
          font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
          margin: 0;
          padding: 20px;
          background: url('https://raw.githubusercontent.com/honeytrapcode/fitness-voice-tracker/main/assets/hope.jpg') no-repeat center center fixed;
          background-size: cover;
          color: #e0e0e0;
        }

    
      .container {
        max-width: 1200px;
        margin: 0 auto;
        background-color: rgba(26, 26, 26, 0.85);
        padding: 30px;
        border-radius: 10px;
        box-shadow: 0 4px 10px rgba(255, 255, 255, 0.05);
      }
    
      h1 {
          color: #ffffff;
          text-align: center;
          margin-bottom: 30px;
        }
        
      h3 {
          color: #ffffff;
          text-align: center;
          margin-bottom: 20px;
        }

    
      .controls, .github-actions {
        display: flex;
        flex-wrap: wrap;
        gap: 15px;
        margin-bottom: 30px;
      }

    .form-entry {
      background-color: #222;
      padding: 15px;
      border-radius: 5px;
      margin-bottom: 20px;
      color: #ccc;
      text-align: center; /* Add this line */
    }
       
    /* Replace the button styling in your CSS with this updated version */
    button {
      padding: 12px 20px;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      font-size: 16px;
      transition: background-color 0.3s;
    }
    
    button:hover {
      filter: brightness(110%);
    }
    
    button:disabled {
      background-color: #444;
      cursor: not-allowed;
    }
    
    /* Start Recording - slightly dark amber */
    #startBtn {
      background-color: #d4a017; /* slightly dark amber */
    }
    
    /* Stop Recording - keep as is */
    button.stop, #stopBtn {
      background-color: #d11a2a; /* original red */
    }
    
    /* Save Data - slightly dark green */
    button.save, #saveBtn {
      background-color: #2e8b57; /* slightly dark green */
      color: white; /* Change text color to white for better contrast */
    }
    
    /* Download CSV - slightly dark blue */
    #downloadBtn {
      background-color: #b83280; /* slightly dark blue */
    }
    
    /* Configure GitHub - slightly dark pink */
    #configureGithubBtn {
      background-color: #b83280; /* slightly dark pink */
    }
    
    #loadFromGithubBtn {
      background-color: #d4a017; /* slightly dark amber */
    }
    /* Create GitHub Backup - slightly dark pink */
     #createBackupBtn {
      background-color: #2e8b57; /* slightly dark green */
    }
    
      .status, .transcript, .github-controls {
        background-color: #222;
        padding: 15px;
        border-radius: 5px;
        margin-bottom: 20px;
        color: #ccc;
      }

       .form-entry {
      background-color: #222;
      padding: 15px;
      border-radius: 5px;
      margin-bottom: 20px;
      color: #ccc;
      text-align: center; /* Add this line */
    }

       /* Add this new class after the form-entry class */
    .form-group {
      flex: 0 0 calc(33.333% - 15px);
      max-width: calc(33.333% - 15px);
      min-width: 200px;
    }

       
      table {
        width: 100%;
        border-collapse: collapse;
        margin-top: 20px;
        color: #ddd;
        overflow-x: auto;
      }
    
      th, td {
        border: 1px solid #444;
        padding: 12px;
        text-align: left;
      }
    
      th {
        background-color: #333;
      }
    
      tr:nth-child(even) {
        background-color: #1c1c1c;
      }
    
      input, select {
        width: 100%;
        padding: 10px;
        border: 1px solid #555;
        border-radius: 4px;
        background-color: #111;
        color: #fff;
      }
    
      label {
        margin-bottom: 5px;
        font-weight: bold;
        color: #bbb;
      }
    
      .record-indicator {
        background-color: #ff4d4d;
        animation: pulse 1.5s infinite;
      }

     .device-info {
      margin-top: 20px;
      padding: 10px;
      background-color: #e0f7fa;
      border-radius: 4px;
      font-size: 14px;
    }
    
      @keyframes pulse {
        0% { opacity: 1; }
        50% { opacity: 0.5; }
        100% { opacity: 1; }
      }
       
    /* Add this media query at the end of your style section */
        @media (max-width: 768px) {
          .form-group {
            flex: 0 0 100%;
            max-width: 100%;
          }
        }
       
    /* Media query for larger screens (laptops/desktops) */
    @media screen and (min-width: 768px) {
      .form-grid {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        grid-template-rows: repeat(4, auto);
        gap: 15px;
      }
    </style>

</head>
<body>
    <div class="container">
        <h1>Tracker</h1>
        
        <div class="controls">
            <button id="startBtn">Start Recording</button>
            <button id="stopBtn" class="stop" disabled>Stop Recording</button>
            <button id="saveBtn" class="save">Save Data</button>
            <button id="downloadBtn">Download CSV</button>
            <input type="file" id="fileInput" accept=".csv" class="hidden">
        </div>

        <div class="github-controls">
        <h3>GitHub Integration</h3>
        <div class="github-status">
            <span id="githubStatus">Not connected to GitHub</span>
            <button id="configureGithubBtn">Configure GitHub</button>
        </div>
        <div class="github-actions">
            <button id="loadFromGithubBtn">Load from GitHub</button>
            <button id="createBackupBtn">Create GitHub Backup</button>
        </div>
        </div>
            
        <div class="status" id="status">Ready to record</div>
        
        <div class="transcript-container">
            <h3>Speech Transcript:</h3>
            <div class="transcript" id="transcript"></div>
        </div>
        
       <div class="form-entry">
        <h3>Manual Entry Form</h3>
        <div class="form-row">
            <div class="form-group">
                <label for="datePicker">Date:</label>
                <input type="date" id="datePicker">
            </div>
            <div class="form-group">
                <label for="wakeTime">Wake Up Time:</label>
                <input type="time" id="wakeTime">
            </div>
            <div class="form-group">
                <label for="milesRun">Miles Run:</label>
                <input type="number" id="milesRun" step="0.1" min="0">
            </div>
        </div>
        <div class="form-row">
            <div class="form-group">
                <label for="pressUps">Press Ups:</label>
                <input type="number" id="pressUps" min="0">
            </div>
            <div class="form-group">
                <label for="sitUps">Sit Ups:</label>
                <input type="number" id="sitUps" min="0">
            </div>
            <div class="form-group">
                <label for="backs">Backs:</label>
                <input type="number" id="backs" min="0">
            </div>
        </div>
        <div class="form-row">
            <div class="form-group">
                <label for="headUps">Head Ups:</label>
                <input type="number" id="headUps" min="0">
            </div>
            <div class="form-group">
                <label for="guitarHours">Guitar Hours:</label>
                <input type="number" id="guitarHours" step="0.25" min="0">
            </div>
            <div class="form-group">
                <label for="drinks">Drinks:</label>
                <input type="number" id="drinks" min="0">
            </div>
        </div>
        <div class="form-row">
            <div class="form-group">
                <label for="flossed">Flossed:</label>
                <select id="flossed">
                    <option value="Yes">Yes</option>
                    <option value="No">No</option>
                </select>
            </div>
            <div class="form-group">
                <label for="finasteride">Finasteride:</label>
                <select id="finasteride">
                    <option value="Yes">Yes</option>
                    <option value="No">No</option>
                </select>
            </div>
            <div class="form-group">
                <label for="moodScore">Mood Score:</label>
                <input type="number" id="moodScore" min="1" max="10" step="1">
            </div>
            <div class="form-group">
                <button id="addEntryBtn" class="save">Add Entry</button>
            </div>
        </div>
    </div>

        <div class="data-display">
            <h3>Your Fitness Data:</h3>
            <div style="overflow-x: auto;">
                <table id="dataTable">
                    <thead>
                        <tr>
                            <th>Date</th>
                            <th>Wake Up Time</th>
                            <th>Miles Run</th>
                            <th>Press Ups</th>
                            <th>Sit Ups</th>
                            <th>Backs</th>
                            <th>Head Ups</th>
                            <th>Guitar Played / Hrs</th>
                            <th>Drinks</th>
                            <th>Flossed</th>
                            <th>Finasteride</th>
                            <th>Mood Score</th>
                            <th>Actions</th>
                        </tr>
                    </thead>
                    <tbody id="tableBody">
                        <!-- Data will be inserted here -->
                    </tbody>
                </table>
            </div>
        </div>
    </div>

    <script>

    // GitHub API Integration for Voice Fitness Tracker

    // Simple script to display the current view type
    function updateDeviceInfo() {
      const deviceInfo = document.getElementById('deviceInfo');
      if (window.innerWidth < 768) {
        deviceInfo.textContent = 'Current view: Mobile (12×1 layout)';
      } else {
        deviceInfo.textContent = 'Current view: Desktop/Laptop (4×3 layout)';
      }
    }
    
    // GitHub API Configuration
    let githubConfig = {
      token: '',
      username: '',
      repository: '',
      branch: 'main',
      isAuthenticated: false
    };
    
    // GitHub Authentication Modal
    // GitHub Authentication Modal - Updated with expiration notice
    function createGitHubAuthModal() {
      const modal = document.createElement('div');
      modal.id = 'githubAuthModal';
      modal.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.5);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 1000;
      `;
    
      const modalContent = document.createElement('div');
      modalContent.style.cssText = `
        background-color: #222;
        padding: 30px;
        border-radius: 8px;
        max-width: 500px;
        width: 100%;
        color: #e0e0e0;
      `;
    
      modalContent.innerHTML = `
        <h2 style="margin-top: 0; color: #ffffff;">GitHub Authentication</h2>
        <p>Enter your GitHub details to save your fitness data to a repository.</p>
        <p style="color: #27ae60;">Your token will be stored securely on this device for 90 days.</p>
        
        <div style="margin-bottom: 15px;">
          <label style="display: block; margin-bottom: 5px; font-weight: bold;">Personal Access Token:</label>
          <input type="password" id="githubToken" style="width: 100%; padding: 10px; border: 1px solid #555; border-radius: 4px; box-sizing: border-box; background-color: #111; color: #fff;">
          <small style="color: #bbb;">Create a token with 'repo' scope at <a href="https://github.com/settings/tokens" target="_blank" style="color: #3498db;">GitHub Token Settings</a></small>
        </div>
        
        <div style="margin-bottom: 15px;">
          <label style="display: block; margin-bottom: 5px; font-weight: bold;">GitHub Username:</label>
          <input type="text" id="githubUsername" style="width: 100%; padding: 10px; border: 1px solid #555; border-radius: 4px; box-sizing: border-box; background-color: #111; color: #fff;">
        </div>
        
        <div style="margin-bottom: 15px;">
          <label style="display: block; margin-bottom: 5px; font-weight: bold;">Repository Name:</label>
          <input type="text" id="githubRepo" style="width: 100%; padding: 10px; border: 1px solid #555; border-radius: 4px; box-sizing: border-box; background-color: #111; color: #fff;">
          <small style="color: #bbb;">Make sure this repository exists in your account</small>
        </div>
        
        <div style="margin-bottom: 15px;">
          <label style="display: block; margin-bottom: 5px; font-weight: bold;">Branch Name:</label>
          <input type="text" id="githubBranch" value="main" style="width: 100%; padding: 10px; border: 1px solid #555; border-radius: 4px; box-sizing: border-box; background-color: #111; color: #fff;">
        </div>
        
        <div style="display: flex; justify-content: space-between; margin-top: 20px;">
          <button id="cancelAuthBtn" style="padding: 10px 20px; background-color: #95a5a6; color: white; border: none; border-radius: 5px; cursor: pointer;">Cancel</button>
          <button id="saveAuthBtn" style="padding: 10px 20px; background-color: #2ecc71; color: white; border: none; border-radius: 5px; cursor: pointer;">Save & Authenticate</button>
        </div>
      `;
    
      modal.appendChild(modalContent);
      document.body.appendChild(modal);
    
      // Event listeners
      document.getElementById('cancelAuthBtn').addEventListener('click', () => {
        document.body.removeChild(modal);
      });
    
      document.getElementById('saveAuthBtn').addEventListener('click', async () => {
        const token = document.getElementById('githubToken').value.trim();
        const username = document.getElementById('githubUsername').value.trim();
        const repository = document.getElementById('githubRepo').value.trim();
        const branch = document.getElementById('githubBranch').value.trim() || 'main';
        
        if (!token || !username || !repository) {
          alert('Please fill in all required fields');
          return;
        }
        
        // Save GitHub config for current session
        githubConfig = {
          token,
          username,
          repository,
          branch,
          isAuthenticated: false
        };
        
        // Test authentication
        try {
          const authenticated = await testGitHubAuth();
          if (authenticated) {
            githubConfig.isAuthenticated = true;
            document.getElementById('githubStatus').textContent = `Connected to ${username}/${repository}`;
            document.getElementById('githubStatus').style.color = '#27ae60';
            document.getElementById('configureGithubBtn').textContent = 'Reconfigure GitHub';
            
            // Set expiration date - 90 days from now
            const expiryDate = new Date();
            expiryDate.setDate(expiryDate.getDate() + 90);
            
            // Securely store credentials in localStorage with expiration
            storeGitHubCredentials(token, username, repository, branch, expiryDate);
            
            // Remove modal
            document.body.removeChild(modal);
          }
        } catch (error) {
          alert(`Authentication failed: ${error.message}`);
        }
      });
      
      // Pre-fill from localStorage if available
      if (localStorage.getItem('githubUsername')) {
        document.getElementById('githubUsername').value = localStorage.getItem('githubUsername');
        document.getElementById('githubRepo').value = localStorage.getItem('githubRepository') || '';
        document.getElementById('githubBranch').value = localStorage.getItem('githubBranch') || 'main';
      }
    }

        
    // Function to encrypt token for storage
    function encryptToken(token) {
      // This is a simple obfuscation, not proper encryption
      // In a production app, consider a more secure approach
      return btoa(token.split('').reverse().join('') + '-' + Date.now());
    }
    
    // Function to decrypt token from storage
    function decryptToken(encrypted) {
      try {
        // Reverse the simple obfuscation
        const parts = atob(encrypted).split('-');
        return parts[0].split('').reverse().join('');
      } catch (e) {
        console.error('Failed to decrypt token', e);
        return null;
      }
    }
    
    // Store GitHub credentials securely
    function storeGitHubCredentials(token, username, repository, branch, expiryDate) {
      localStorage.setItem('githubUsername', username);
      localStorage.setItem('githubRepository', repository);
      localStorage.setItem('githubBranch', branch);
      localStorage.setItem('githubTokenExpiry', expiryDate.toISOString());
      
      // Store encrypted token
      localStorage.setItem('githubTokenSecure', encryptToken(token));
    }
    
    // Load GitHub credentials and check expiration
    function loadGitHubCredentials() {
      const username = localStorage.getItem('githubUsername');
      const repository = localStorage.getItem('githubRepository');
      const branch = localStorage.getItem('githubBranch') || 'main';
      const expiryDateStr = localStorage.getItem('githubTokenExpiry');
      const encryptedToken = localStorage.getItem('githubTokenSecure');
      
      if (!username || !repository || !encryptedToken || !expiryDateStr) {
        return null;
      }
      
      // Check if token has expired
      const expiryDate = new Date(expiryDateStr);
      const now = new Date();
      
      if (now > expiryDate) {
        // Token expired, clear credentials
        localStorage.removeItem('githubTokenSecure');
        localStorage.removeItem('githubTokenExpiry');
        return {
          username,
          repository, 
          branch,
          expired: true
        };
      }
      
      // Token is valid
      const token = decryptToken(encryptedToken);
      if (!token) return null;
      
      return {
        token,
        username,
        repository,
        branch,
        expiryDate,
        expired: false
      };
    }
    
    // Check GitHub authentication on page load
    async function checkGitHubAuth() {
      const credentials = loadGitHubCredentials();
      const statusElement = document.getElementById('githubStatus');
      
      if (!credentials) {
        statusElement.textContent = 'Not connected to GitHub';
        statusElement.style.color = '#ccc';
        return;
      }
      
      if (credentials.expired) {
        statusElement.textContent = `Token expired for ${credentials.username}/${credentials.repository}`;
        statusElement.style.color = '#e74c3c';
        return;
      }
      
      // Compute days remaining until expiration
      const daysRemaining = Math.ceil((credentials.expiryDate - new Date()) / (1000 * 60 * 60 * 24));
      
      // Set up config with loaded credentials
      githubConfig = {
        token: credentials.token,
        username: credentials.username,
        repository: credentials.repository,
        branch: credentials.branch,
        isAuthenticated: false
      };
      
      try {
        // Test if the saved token is still valid
        const authenticated = await testGitHubAuth();
        if (authenticated) {
          githubConfig.isAuthenticated = true;
          statusElement.textContent = `Connected to ${credentials.username}/${credentials.repository} (${daysRemaining} days remaining)`;
          statusElement.style.color = '#27ae60';
          document.getElementById('configureGithubBtn').textContent = 'Reconfigure GitHub';
        } else {
          statusElement.textContent = `Authentication failed for ${credentials.username}/${credentials.repository}`;
          statusElement.style.color = '#e74c3c';
        }
      } catch (error) {
        statusElement.textContent = `Authentication error: ${error.message}`;
        statusElement.style.color = '#e74c3c';
      }
    }
    
        // Test GitHub Authentication
        async function testGitHubAuth() {
          try {
            const response = await fetch(`https://api.github.com/repos/${githubConfig.username}/${githubConfig.repository}`, {
              headers: {
                'Authorization': `token ${githubConfig.token}`,
                'Accept': 'application/vnd.github.v3+json'
              }
            });
            
            if (response.status === 200) {
              return true;
            } else if (response.status === 404) {
              throw new Error('Repository not found. Make sure it exists and you have access to it.');
            } else {
              const data = await response.json();
              throw new Error(data.message || 'Authentication failed');
            }
          } catch (error) {
            console.error('GitHub authentication error:', error);
            throw error;
          }
        }
        
        // Get existing file content from GitHub
        async function getFileFromGitHub(path) {
          try {
            const response = await fetch(`https://api.github.com/repos/${githubConfig.username}/${githubConfig.repository}/contents/${path}?ref=${githubConfig.branch}`, {
              headers: {
                'Authorization': `token ${githubConfig.token}`,
                'Accept': 'application/vnd.github.v3+json'
              }
            });
            
            if (response.status === 200) {
              const data = await response.json();
              // GitHub API returns content as base64 encoded
              return {
                content: atob(data.content),
                sha: data.sha // We need this for updating the file later
              };
            } else if (response.status === 404) {
              // File doesn't exist yet
              return null;
            } else {
              const data = await response.json();
              throw new Error(data.message || 'Failed to get file');
            }
          } catch (error) {
            console.error('Error fetching file from GitHub:', error);
            throw error;
          }
        }
        
        // Save file to GitHub
        async function saveFileToGitHub(path, content, message) {
          try {
            // First check if file exists to get its SHA
            let existingFile = null;
            try {
              existingFile = await getFileFromGitHub(path);
            } catch (err) {
              // File doesn't exist yet, which is fine
            }
            
            const body = {
              message: message,
              content: btoa(content), // Convert to base64
              branch: githubConfig.branch
            };
            
            // If file exists, we need to include its SHA for updating
            if (existingFile && existingFile.sha) {
              body.sha = existingFile.sha;
            }
            
            const response = await fetch(`https://api.github.com/repos/${githubConfig.username}/${githubConfig.repository}/contents/${path}`, {
              method: 'PUT',
              headers: {
                'Authorization': `token ${githubConfig.token}`,
                'Accept': 'application/vnd.github.v3+json',
                'Content-Type': 'application/json'
              },
              body: JSON.stringify(body)
            });
            
            if (response.status === 200 || response.status === 201) {
              return await response.json();
            } else {
              const data = await response.json();
              throw new Error(data.message || 'Failed to save file');
            }
          } catch (error) {
            console.error('Error saving file to GitHub:', error);
            throw error;
          }
        }
        
        // Save fitness data to GitHub
        async function saveFitnessDataToGitHub() {
          if (!githubConfig.isAuthenticated) {
            alert('Please configure your GitHub account first');
            createGitHubAuthModal();
            return false;
          }
          
          try {
            const csv = convertToCSV();
            const timestamp = new Date().toISOString().replace(/:/g, '-');
            const filename = 'tracker.csv';
            
            // Save the main CSV file
            await saveFileToGitHub(
              filename,
              csv,
              `Update fitness data - ${timestamp}`
            );
            
            // Also save a backup with timestamp
            await saveFileToGitHub(
              `backups/tracker_${timestamp}.csv`,
              csv,
              `Backup fitness data - ${timestamp}`
            );
            
            return true;
          } catch (error) {
            console.error('Error saving to GitHub:', error);
            alert(`Failed to save to GitHub: ${error.message}`);
            return false;
          }
        }
        
        // Load fitness data from GitHub
        async function loadFitnessDataFromGitHub() {
          if (!githubConfig.isAuthenticated) {
            alert('Please configure your GitHub account first');
            createGitHubAuthModal();
            return false;
          }
          
          try {
            const fileData = await getFileFromGitHub('tracker.csv');
            
            if (fileData && fileData.content) {
              fitnessData = parseCSV(fileData.content);
              renderTable();
              status.textContent = 'Data loaded from GitHub successfully';
              return true;
            } else {
              status.textContent = 'No existing data found on GitHub';
              return false;
            }
          } catch (error) {
            console.error('Error loading from GitHub:', error);
            alert(`Failed to load from GitHub: ${error.message}`);
            return false;
          }
        }
        
        // Helper function to format date as DD/MM/YYYY
        function formatDate(date) {
            const d = new Date(date);
            const day = String(d.getDate()).padStart(2, '0');
            const month = String(d.getMonth() + 1).padStart(2, '0');
            const year = d.getFullYear();
            return `${day}/${month}/${year}`;
        }

        // Helper function to parse date from DD/MM/YYYY format
        function parseDate(dateStr) {
            const [day, month, year] = dateStr.split('/');
            return `${year}-${month}-${day}`;
        }

        // Initialize data array from sample data
        let fitnessData = [
            {
                date: '27/12/2024',
                wakeUpTime: '10:30',
                milesRun: 2.0,
                pressUps: 100,
                sitUps: 100,
                backs: 50,
                headUps: 0,
                guitarHours: 0.00,
                drinks: 6,
                flossed: 'No',
                finasteride: 'Yes',
                moodScore: '7'
            },
            {
                date: '28/12/2024',
                wakeUpTime: '12:00',
                milesRun: 5.6,
                pressUps: 100,
                sitUps: 0,
                backs: 60,
                headUps: 50,
                guitarHours: 2.00,
                drinks: 1,
                flossed: 'No',
                finasteride: 'Yes',
                moodScore: '7'
            },
            {
                date: '29/12/2024',
                wakeUpTime: '11:00',
                milesRun: 0.5,
                pressUps: 50,
                sitUps: 25,
                backs: 25,
                headUps: 0,
                guitarHours: 2.00,
                drinks: 0,
                flossed: 'Yes',
                finasteride: 'Yes',
                moodScore: '7'
            }
        ];

        // DOM Elements
        const startBtn = document.getElementById('startBtn');
        const stopBtn = document.getElementById('stopBtn');
        const saveBtn = document.getElementById('saveBtn');
        const downloadBtn = document.getElementById('downloadBtn');
        // const uploadBtn = document.getElementById('uploadBtn');
        const fileInput = document.getElementById('fileInput');
        const addEntryBtn = document.getElementById('addEntryBtn');
        const status = document.getElementById('status');
        const transcript = document.getElementById('transcript');
        const tableBody = document.getElementById('tableBody');

        // Speech recognition setup
        let recognition = null;
        let isRecording = false;

        if ('SpeechRecognition' in window || 'webkitSpeechRecognition' in window) {
            recognition = new (window.SpeechRecognition || window.webkitSpeechRecognition)();
            recognition.continuous = true;
            recognition.interimResults = true;
            recognition.lang = 'en-US';
            
            recognition.onstart = () => {
                status.innerHTML = '<span class="record-indicator"></span> Recording...';
                isRecording = true;
                startBtn.disabled = true;
                stopBtn.disabled = false;
            };

            // This function handles the transcript after recording stops
            function handleTranscriptAfterRecording() {
                const text = transcript.innerText || transcript.textContent;
                
                if (!text || text.trim().length === 0) {
                    status.textContent = 'No speech detected';
                    return;
                }
                
                // Call the actual processing function with the transcribed text
                // Note: The NLP function is named "processTranscript" in your code
                const result = processTranscript(text, fitnessData, status);
                
                if (result && result.success) {
                    // Update the table to show the new/updated entry
                    renderTable();
                    
                    // Optionally clear the transcript after processing
                    // transcript.textContent = '';
                }
            }
            
            recognition.onend = () => {
                status.textContent = 'Recording stopped';
                isRecording = false;
                startBtn.disabled = false;
                stopBtn.disabled = true;
                // Process the transcript after recording stops
                handleTranscriptAfterRecording();
            };
            
            recognition.onresult = (event) => {
                let interimTranscript = '';
                let finalTranscript = '';
                
                for (let i = event.resultIndex; i < event.results.length; i++) {
                    const result = event.results[i];
                    if (result.isFinal) {
                        finalTranscript += result[0].transcript;
                    } else {
                        interimTranscript += result[0].transcript;
                    }
                }
                
                transcript.innerHTML = finalTranscript + '<i style="color: #888;">' + interimTranscript + '</i>';
            };
            
            recognition.onerror = (event) => {
                status.textContent = 'Error: ' + event.error;
                startBtn.disabled = false;
                stopBtn.disabled = true;
            };
        } else {
            status.textContent = 'Speech recognition not supported in this browser.';
            startBtn.disabled = true;
        }

        /**
         * Daily Activity Tracker - Natural Language Processing Functions
         * Processes speech transcripts to extract health and fitness metrics
         */
        
        // Store all regex patterns in one place for easier maintenance
        const PATTERNS = {
          date: {
            today: /today/i,
            yesterday: /yesterday/i,
            specificDate: /on\s+(\d{1,2})[\/\-\.](\d{1,2})(?:[\/\-\.](\d{2,4}))?/i
          },
        
          time: {
            // Now supports: "got up", "rose", "was up", etc.
            wakeUp: /(?:woke\s+(?:up\s+)?|got\s+up\s+|rose\s+|was\s+up\s+)(?:at\s*)?(\d{1,2}):?(\d{2})?\s*(am|pm)?/i
          },
        
          exercise: {
            // Now supports: jogged, ran, went for a run, did 3.5 miles, etc.
            miles: /(?:(?:ran|run|jogged|went\s+(?:for\s+)?a\s+run|did)\s+)?(\d+\.?\d*)\s*(?:miles?|mi\b)/i,
        
            // Added variations: push ups, press ups, did 50 pushups, etc.
            pushups: /(?:did\s+)?(\d+)\s*(?:push\s*ups?|press\s*ups?)/i,
        
            // Added “did” variation
            situps: /(?:did\s+)?(\d+)\s*sit\s*ups?/i,
            backs: /(?:did\s+)?(\d+)\s*backs?/i,
            headUps: /(?:did\s+)?(\d+)\s*head\s*ups?/i
          },
        
          activities: {
            guitar1: /(?:played|practice[d]?)\s+guitar\s+(?:for\s+)?(\d+\.?\d*)\s*(?:hour?|hours?|hrs?)/i,
            guitar2: /(\d+\.?\d*)\s*(?:hour?|hours?|hrs?)\s+(?:of\s+)?guitar/i,
            drinks1: /(\d+)\s*drinks?/i,
            drinks2: /(?:had|drank|consumed)\s+(\d+)\s*(?:drinks?|beers?|glasses?|shots?)/i
          },
        
          health: {
            // Added more phrases for YES
            flossYes: /(?:flossed|did\s+floss|i\s+flossed|brushed\s+and\s+flossed)/i,
        
            // Added contractions + negation
            flossNo: /(?:(?:did(?:n't| not)|no)\s+floss|forgot\s+to\s+floss)/i,
        
            finYes: /(?:took|had|used)\s+(?:my\s+)?finasteride/i,
            finNo: /(?:did(?:n't| not)\s+take|no\s+finasteride|forgot\s+finasteride)/i,
        
            // Support “mood is 8”, “feeling 7”, “my mood today was 6”
            mood: /(?:mood|feeling)(?:\s+(?:is|was|:))?\s+(\d{1,2})/i
          }
        };

        // New generalized pattern for detecting multiple numeric activities
        const MULTI_METRIC_PATTERN = /(\d+\.?\d*)\s*(press\s*ups?|push\s*ups?|sit\s*ups?|backs?|head\s*ups?|miles|drinks?|beers?)/gi;

        
        /**
         * Format a Date object to DD/MM/YYYY
         * @param {Date} date - The date to format
         * @return {string} Formatted date string
         */
        function formatDate(date) {
          return `${String(date.getDate()).padStart(2, '0')}/${String(date.getMonth() + 1).padStart(2, '0')}/${date.getFullYear()}`;
        }
        
        /**
         * Extract date from transcript text
         * @param {string} text - The transcript text
         * @return {Date} Extracted date or today's date if not found
         */
        function extractDate(text) {
          let date = new Date();
          
          if (PATTERNS.date.yesterday.test(text)) {
            date.setDate(date.getDate() - 1);
          } else {
            const dateMatch = text.match(PATTERNS.date.specificDate);
            if (dateMatch) {
              const day = parseInt(dateMatch[1], 10);
              const month = parseInt(dateMatch[2], 10) - 1; // JS months are 0-indexed
              let year = dateMatch[3] ? parseInt(dateMatch[3], 10) : date.getFullYear();
              
              // Handle 2-digit years
              if (year < 100) {
                year += 2000;
              }
              
              // Create new date object with validation
              const specifiedDate = new Date(year, month, day);
              if (!isNaN(specifiedDate.getTime())) {
                date = specifiedDate;
              }
            }
          }
          
          return date;
        }
        
        /**
         * Extract wake-up time from transcript text
         * @param {string} text - The transcript text
         * @return {string|null} Formatted wake-up time or null if not found
         */
        function extractWakeUpTime(text) {
          const wakeTimeMatch = text.match(PATTERNS.time.wakeUp);
          if (!wakeTimeMatch) return null;
          
          let hour = parseInt(wakeTimeMatch[1], 10);
          const minute = wakeTimeMatch[2] ? parseInt(wakeTimeMatch[2], 10) : 0;
          const period = wakeTimeMatch[3] ? wakeTimeMatch[3].toLowerCase() : null;
          
          // Convert to 24-hour format
          if (period === 'pm' && hour < 12) {
            hour += 12;
          } else if (period === 'am' && hour === 12) {
            hour = 0;
          }
          
          // Validate hour and minute
          if (hour < 0 || hour > 23 || minute < 0 || minute > 59) {
            console.warn('Invalid time extracted:', wakeTimeMatch[0]);
            return null;
          }
          
          return `${String(hour).padStart(2, '0')}:${String(minute).padStart(2, '0')}`;
        }
        
        /**
         * Extract a numeric value using a regex pattern
         * @param {string} text - The transcript text
         * @param {RegExp} pattern - Regular expression with a capturing group for the number
         * @param {Function} parseFunc - Function to parse the string (parseInt or parseFloat)
         * @param {number} min - Minimum valid value
         * @param {number} max - Maximum valid value
         * @return {number|null} Extracted value or null if not found/invalid
         */
        function extractNumericValue(text, pattern, parseFunc, min = 0, max = Infinity) {
          const match = text.match(pattern);
          if (!match) return null;
          
          const value = parseFunc(match[1]);
          if (isNaN(value) || value < min || value > max) {
            console.warn('Invalid value extracted:', match[0]);
            return null;
          }
          
          return value;
        }
        
        /**
         * Extract a boolean value based on presence of yes/no patterns
         * @param {string} text - The transcript text
         * @param {RegExp} yesPattern - Pattern indicating "yes"
         * @param {RegExp} noPattern - Pattern indicating "no"
         * @return {string|null} "Yes", "No", or null if not determined
         */
        function extractBooleanValue(text, yesPattern, noPattern) {
          if (yesPattern.test(text) && !noPattern.test(text)) {
            return 'Yes';
          } else if (noPattern.test(text)) {
            return 'No';
          }
          return null;
        }
        function extractMultipleMetrics(text) {
          const matches = text.matchAll(MULTI_METRIC_PATTERN);
          const metrics = {
            pressUps: null,
            sitUps: null,
            backs: null,
            headUps: null,
            milesRun: null,
            drinks: null
          };
        
          for (const match of matches) {
            const value = parseFloat(match[1]);
            const label = match[2].toLowerCase();
        
            if (label.includes('push') || label.includes('press')) {
              metrics.pressUps = value;
            } else if (label.includes('sit')) {
              metrics.sitUps = value;
            } else if (label.includes('backs')) {
              metrics.backs = value;
            } else if (label.includes('head')) {
              metrics.headUps = value;
            } else if (label.includes('mile')) {
              metrics.milesRun = value;
            } else if (label.includes('drink') || label.includes('beer')) {
              metrics.drinks = value;
            }
          }
        
          return metrics;
        }

        /**
         * Update or create an entry in the fitness data array
         * @param {Array} fitnessData - Array of fitness entries
         * @param {Object} extractedData - Object containing extracted values
         * @return {Object} The updated or created entry
         */
        function updateFitnessData(fitnessData, extractedData) {
          const { formattedDate, ...metrics } = extractedData;
          
          // Look for existing entry for this date
          const existingIndex = fitnessData.findIndex(entry => entry.date === formattedDate);
          
          if (existingIndex >= 0) {
            // Update existing entry with non-null values
            Object.entries(metrics).forEach(([key, value]) => {
              if (value !== null) {
                fitnessData[existingIndex][key] = value;
              }
            });
            
            return fitnessData[existingIndex];
          } else {
            // Create new entry with default values
            const defaults = {
              wakeUpTime: '08:00',
              milesRun: 0,
              pressUps: 0,
              sitUps: 0,
              backs: 0,
              headUps: 0,
              guitarHours: 0,
              drinks: 0,
              flossed: 'No',
              finasteride: 'No',
              moodScore: ''
            };
            
            // Merge defaults with extracted values
            const newEntry = {
              date: formattedDate,
              ...defaults,
              ...Object.fromEntries(Object.entries(metrics).filter(([_, v]) => v !== null))
            };
            
            fitnessData.push(newEntry);
            return newEntry;
          }
        }
        
        /**
         * Generate a summary of extracted information
         * @param {Object} extractedData - Object containing extracted values
         * @return {string} Human-readable summary
         */
        
        function generateSummary(extractedData) {
          const { formattedDate, ...metrics } = extractedData;
          
          let summary = `For ${formattedDate}:\n`;
          const parts = [];
          
          if (metrics.wakeUpTime) parts.push(`Wake up: ${metrics.wakeUpTime}`);
          if (metrics.milesRun) parts.push(`${metrics.milesRun} miles run`);
          if (metrics.pressUps) parts.push(`${metrics.pressUps} pushups`);
          if (metrics.sitUps) parts.push(`${metrics.sitUps} situps`);
          if (metrics.backs) parts.push(`${metrics.backs} backs`);
          if (metrics.headUps) parts.push(`${metrics.headUps} head-ups`);
          if (metrics.guitarHours) parts.push(`${metrics.guitarHours} hrs guitar`);
          if (metrics.drinks) parts.push(`${metrics.drinks} drinks`);
          if (metrics.flossed) parts.push(`flossed: ${metrics.flossed}`);
          if (metrics.finasteride) parts.push(`finasteride: ${metrics.finasteride}`);
          if (metrics.moodScore) parts.push(`moodScore: ${metrics.moodScore}`);
          
          return summary + parts.join(', ');
        }
        /**
         * Main function to process a transcript and extract activity data
         * @param {string} text - The transcript text
         * @param {Array} fitnessData - Array of fitness data entries
         * @param {HTMLElement} statusElement - Element to update with status
         * @return {Object} Object containing extracted and processed data
         */
       // Process the transcript to extract fitness data
        function processTranscript(text, fitnessData, statusElement) {
          try {
            if (!text || typeof text !== 'string') {
              throw new Error('No valid text provided');
            }
            
            if (statusElement) {
              statusElement.textContent = 'Processing speech...';
            }
            
            // Extract date and format it
            const date = extractDate(text);
            const formattedDate = formatDate(date);
            
            // Extract all metrics
            const multiMetrics = extractMultipleMetrics(text);

            const extractedData = {
              formattedDate,
              wakeUpTime: extractWakeUpTime(text),
              milesRun: multiMetrics.milesRun,
              pressUps: multiMetrics.pressUps,
              sitUps: multiMetrics.sitUps,
              backs: multiMetrics.backs,
              headUps: multiMetrics.headUps,
              drinks: multiMetrics.drinks,
              flossed: extractBooleanValue(text, PATTERNS.health.flossYes, PATTERNS.health.flossNo),
              finasteride: extractBooleanValue(text, PATTERNS.health.finYes, PATTERNS.health.finNo),
              moodScore: extractNumericValue(text, PATTERNS.health.mood, parseInt, 1, 10)
            };
            
            // Handle guitarHours separately
            extractedData.guitarHours = 
              extractNumericValue(text, PATTERNS.activities.guitar1, parseFloat, 0, 24) || 
              extractNumericValue(text, PATTERNS.activities.guitar2, parseFloat, 0, 24);

            
            // Handle guitar hours (try both patterns)
            extractedData.guitarHours = extractNumericValue(text, PATTERNS.activities.guitar1, parseFloat, 0, 24) || 
                                        extractNumericValue(text, PATTERNS.activities.guitar2, parseFloat, 0, 24);
            
            // Update fitness data storage
            const updatedEntry = updateFitnessData(fitnessData, extractedData);
            
            // Generate summary for display
            const summary = generateSummary(extractedData);
            
            if (statusElement) {
              statusElement.textContent = summary;
            }
            
            return {
              success: true,
              extractedData,
              updatedEntry,
              summary
            };
          } catch (error) {
            console.error('Error processing transcript:', error);
            
            if (statusElement) {
              statusElement.textContent = 'Error processing transcript: ' + error.message;
            }
            
            return {
              success: false,
              error: error.message
            };
          }
        }
        // Render table with current data
        function renderTable() {
            tableBody.innerHTML = '';
            
            // Sort data by date (newest first)
            fitnessData.sort((a, b) => {
                const dateA = a.date.split('/').reverse().join('');
                const dateB = b.date.split('/').reverse().join('');
                return dateB.localeCompare(dateA);
            });
            
            fitnessData.forEach((entry, index) => {
                const row = document.createElement('tr');
                
                row.innerHTML = `
                    <td>${entry.date}</td>
                    <td>${entry.wakeUpTime}</td>
                    <td>${entry.milesRun}</td>
                    <td>${entry.pressUps}</td>
                    <td>${entry.sitUps}</td>
                    <td>${entry.backs}</td>
                    <td>${entry.headUps}</td>
                    <td>${entry.guitarHours}</td>
                    <td>${entry.drinks}</td>
                    <td>${entry.flossed}</td>
                    <td>${entry.finasteride}</td>
                    <td>${entry.moodScore}</td>
                    <td>
                        <button class="edit-btn" data-index="${index}">Edit</button>
                        <button class="delete-btn" data-index="${index}">Delete</button>
                    </td>
                `;
                
                tableBody.appendChild(row);
            });
            
            // Add event listeners to edit and delete buttons
            document.querySelectorAll('.edit-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    const index = this.getAttribute('data-index');
                    editEntry(index);
                });
            });
            
            document.querySelectorAll('.delete-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    const index = this.getAttribute('data-index');
                    if (confirm('Are you sure you want to delete this entry?')) {
                        fitnessData.splice(index, 1);
                        renderTable();
                    }
                });
            });
        }

        // Edit an existing entry
        function editEntry(index) {
            const entry = fitnessData[index];
            
            // Fill the form with the entry data
            document.getElementById('datePicker').value = parseDate(entry.date);
            document.getElementById('wakeTime').value = entry.wakeUpTime;
            document.getElementById('milesRun').value = entry.milesRun;
            document.getElementById('pressUps').value = entry.pressUps;
            document.getElementById('sitUps').value = entry.sitUps;
            document.getElementById('backs').value = entry.backs;
            document.getElementById('headUps').value = entry.headUps;
            document.getElementById('guitarHours').value = entry.guitarHours;
            document.getElementById('drinks').value = entry.drinks;
            document.getElementById('flossed').value = entry.flossed;
            document.getElementById('finasteride').value = entry.finasteride;
            document.getElementById('moodScore').value = entry.moodScore;
            
            // Change the Add Entry button to Update Entry
            addEntryBtn.textContent = 'Update Entry';
            addEntryBtn.setAttribute('data-edit-index', index);
            
            // Scroll to the form
            document.querySelector('.form-entry').scrollIntoView({ behavior: 'smooth' });
        }

        // Convert data to CSV
        function convertToCSV() {
            // Define headers
            const headers = ['Date', 'Wake Up Time', 'Miles Run', 'Press Ups', 'Sit Ups', 'Backs', 'Head Ups', 
                            'Guitar Played / Hrs', 'Drinks', 'Flossed', 'Finasteride','Mood Score'];
            
            // Sort data by date (oldest first for CSV)
            const sortedData = [...fitnessData].sort((a, b) => {
                const dateA = a.date.split('/').reverse().join('');
                const dateB = b.date.split('/').reverse().join('');
                return dateA.localeCompare(dateB);
            });
            
            // Create CSV rows
            const csvRows = [];
            csvRows.push(headers.join(','));
            
            sortedData.forEach(entry => {
                const values = [
                    entry.date,
                    entry.wakeUpTime,
                    entry.milesRun,
                    entry.pressUps,
                    entry.sitUps,
                    entry.backs,
                    entry.headUps,
                    entry.guitarHours,
                    entry.drinks,
                    entry.flossed,
                    entry.finasteride,
                    entry.moodScore
                ];
                csvRows.push(values.join(','));
            });
            
            return csvRows.join('\n');
        }

        // Parse CSV data
        function parseCSV(csvText) {
            const lines = csvText.split('\n');
            const headers = lines[0].split(',');
            
            const parsedData = [];
            
            for (let i = 1; i < lines.length; i++) {
                if (!lines[i].trim()) continue;
                
                const values = lines[i].split(',');
                const entry = {
                    date: values[0] || '',
                    wakeUpTime: values[1] || '',
                    milesRun: parseFloat(values[2]) || 0,
                    pressUps: parseInt(values[3]) || 0,
                    sitUps: parseInt(values[4]) || 0,
                    backs: parseInt(values[5]) || 0,
                    headUps: parseInt(values[6]) || 0,
                    guitarHours: parseFloat(values[7]) || 0,
                    drinks: parseInt(values[8]) || 0,
                    flossed: values[9] || 'No',
                    finasteride: values[10] || 'No',
                    moodScore: values[11] || ''
                };
                
                parsedData.push(entry);
            }
            
            return parsedData;
        }

        // Event Listeners
        startBtn.addEventListener('click', () => {
            if (recognition) {
                transcript.textContent = '';
                recognition.start();
            }
        });

        stopBtn.addEventListener('click', () => {
            if (recognition && isRecording) {
                recognition.stop();
            }
        });

        downloadBtn.addEventListener('click', () => {
            const csv = convertToCSV();
            const blob = new Blob([csv], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.setAttribute('href', url);
            a.setAttribute('download', 'tracker.csv');
            a.click();
        });

       /* uploadBtn.addEventListener('click', () => {
            fileInput.click();
        });*/

        fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(event) {
                    fitnessData = parseCSV(event.target.result);
                    renderTable();
                    status.textContent = 'CSV file imported successfully';
                };
                reader.readAsText(file);
            }
        });

        addEntryBtn.addEventListener('click', () => {
            const editIndex = addEntryBtn.getAttribute('data-edit-index');
            
            const newEntry = {
                date: formatDate(document.getElementById('datePicker').value),
                wakeUpTime: document.getElementById('wakeTime').value,
                milesRun: parseFloat(document.getElementById('milesRun').value) || 0,
                pressUps: parseInt(document.getElementById('pressUps').value) || 0,
                sitUps: parseInt(document.getElementById('sitUps').value) || 0,
                backs: parseInt(document.getElementById('backs').value) || 0,
                headUps: parseInt(document.getElementById('headUps').value) || 0,
                guitarHours: parseFloat(document.getElementById('guitarHours').value) || 0,
                drinks: parseInt(document.getElementById('drinks').value) || 0,
                flossed: document.getElementById('flossed').value,
                finasteride: document.getElementById('finasteride').value,
                moodScore: parseInt(document.getElementById('moodScore').value)
            };
            
            if (editIndex !== null) {
                // Update existing entry
                fitnessData[editIndex] = newEntry;
                addEntryBtn.textContent = 'Add Entry';
                addEntryBtn.removeAttribute('data-edit-index');
            } else {
                // Check if entry for this date already exists
                const existingIndex = fitnessData.findIndex(entry => entry.date === newEntry.date);
                
                if (existingIndex >= 0) {
                    if (confirm('An entry for this date already exists. Do you want to update it?')) {
                        fitnessData[existingIndex] = newEntry;
                    } else {
                        return;
                    }
                } else {
                    // Add new entry
                    fitnessData.push(newEntry);
                }
            }
            
            // Clear form
            document.getElementById('datePicker').value = '';
            document.getElementById('wakeTime').value = '';
            document.getElementById('milesRun').value = '';
            document.getElementById('pressUps').value = '';
            document.getElementById('sitUps').value = '';
            document.getElementById('backs').value = '';
            document.getElementById('headUps').value = '';
            document.getElementById('guitarHours').value = '';
            document.getElementById('drinks').value = '';
            document.getElementById('flossed').value = 'Yes';
            document.getElementById('finasteride').value = 'Yes';
            document.getElementById('moodScore').value = '';
            
            // Update table
            renderTable();
        });

        // Initialize table on page load
        renderTable();

        // Set today's date in the date picker by default
        const today = new Date();
        const year = today.getFullYear();
        const month = String(today.getMonth() + 1).padStart(2, '0');
        const day = String(today.getDate()).padStart(2, '0');
        document.getElementById('datePicker').value = `${year}-${month}-${day}`;

        // Add these event listeners at the end of your script section

// GitHub related event listeners
document.getElementById('configureGithubBtn').addEventListener('click', () => {
    createGitHubAuthModal();
});

document.getElementById('loadFromGithubBtn').addEventListener('click', async () => {
    const status = document.getElementById('status');
    status.textContent = 'Loading data from GitHub...';
    
    try {
        const success = await loadFitnessDataFromGitHub();
        if (success) {
            status.textContent = 'Data loaded from GitHub successfully';
        }
    } catch (error) {
        status.textContent = `Error loading from GitHub: ${error.message}`;
    }
});

document.getElementById('createBackupBtn').addEventListener('click', async () => {
    const status = document.getElementById('status');
    status.textContent = 'Creating backup on GitHub...';
    
    try {
        const success = await saveFitnessDataToGitHub();
        if (success) {
            status.textContent = 'Backup created on GitHub successfully';
        }
    } catch (error) {
        status.textContent = `Error creating backup: ${error.message}`;
    }
});

// Update the save button to use GitHub
saveBtn.addEventListener('click', async () => {
    const status = document.getElementById('status');
    status.textContent = 'Saving data to GitHub...';
    
    if (!githubConfig.isAuthenticated) {
        status.textContent = 'GitHub authentication required';
        createGitHubAuthModal();
        return;
    }
    
    try {
        const success = await saveFitnessDataToGitHub();
        if (success) {
            status.textContent = 'Data saved to GitHub successfully';
        }
    } catch (error) {
        status.textContent = `Error saving to GitHub: ${error.message}`;
    }
});

    // Check for saved GitHub credentials on page load
window.addEventListener('DOMContentLoaded' () => {
    checkGitHubAuth();
    
    const username = localStorage.getItem('githubUsername');
    const repository = localStorage.getItem('githubRepository');
    const branch = localStorage.getItem('githubBranch') || 'main';
    
    if (username && repository) {
        githubConfig.username = username;
        githubConfig.repository = repository;
        githubConfig.branch = branch;
        
        document.getElementById('githubStatus').textContent = 
            `Credentials saved for ${username}/${repository} (not connected)`;
        document.getElementById('githubStatus').style.color = '#f39c12';
        
        // Automatically attempt to load data from GitHub if authenticated
        try {
            if (githubConfig.isAuthenticated) {
                const status = document.getElementById('status');
                status.textContent = 'Automatically loading data from GitHub...';
                
                const success = await loadFitnessDataFromGitHub();
                if (success) {
                    status.textContent = 'Data automatically loaded from GitHub successfully';
                } else {
                    status.textContent = 'No data found on GitHub or load unsuccessful';
                }
            }
        } catch (error) {
            console.error('Automatic GitHub load error:', error);
            document.getElementById('status').textContent = 
                `Automatic load failed: ${error.message}`;
        }
    }
});
    </script>
</body>
</html>
